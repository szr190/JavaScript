<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>hello world~!!</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
    <style>
        *{margin: 0;padding: 0;}
        body{font:16px/1.5 'Microsoft Yahei';}
        .clearfix:after{content:'';display:block;clear:both;}
        .fl{float:left;}
        .fr{float:right;}
        .box{

        }

    </style>
</head>
<body>
    <span class="box"></span>
    <p class="box"></p>

</body>
    <script>
        /*
        面向对象是一种思想
            面向对象4个大特征：

            抽象:把某些特征抽象出来
            封装:把对象的某些功能封装起来,使用者不需要知道对象内部是怎么实现的。
            继承:子类继承父类
            多态:多功能

        对象:属性和方法




        */


        //原始改进模式
        // function person(name,age){
        //     return {
        //         name:name,
        //         age:age
        //     };
        // }
        // var person1 = person('二狗',20);
        // var person2 = person('旺财',21);
        // var person3 = person('空白',20);
        // var person4 = person('逐梦',20);

        //工厂方式

        // function person(name,age){
        //     var obj= {};//原材料

        //     //加工
        //     obj.name = name;
        //     obj.age = age;
        //     obj.showname= function(){
        //         alert(this.name);
        //     }
        //     //出厂
        //     return obj;

        // }
        // var person1 = person('二狗',20);


        /* 构造函数 类(class)

        */

        //var obj = new Array();
        //console.log( Object );
        //Array是一个构造函数
        //此时obj是一个Array构造函数的一个实例对象
        //console.log(obj);


        // function Person(name,age){
        //     //var obj = {};//自动创建
        //     //console.log(this);//this指向这个对象
        //     this.name = name;
        //     this.age = age;
        //     //return obj;//自动返回
        // }

        // var p1 = new Person('二狗',20) ;
        // //此时Person是构造函数,p1是Person的一个实例
        // console.log( p1 );
        // //Person('旺财',30);



        function Person(name,age){
            //给对象加属性
            this.name = name;
            this.age = age;
            this.showname = function(){
                alert(this.name);
            }

        }
        var p1 = new Person('二狗',20);
        //p1.showname();//二狗
        var p2 = new Person('旺财',22);
        //p2.showname();//旺财

        // oDiv.onclick = function(){
        //     console.log(this);
        // }

        // function fn(){}//函数是一个特殊的对象
        // fn.abc = 666;
        // console.log( fn.abc);

        //console.log( p1.showname == p2.showname );//false;

        //function(){} 等同于 new Function();
        //var obj = {}; //new Object();

       /*原始(基本)数据类型/引用类型

         原始数据类型:string、number、NaN、null、Boolea、undefined
            原始数据类型比较，只需要比较值是不是相等；
         引用数据类型:json、array、function、node

           引用数据类型之间的比较是内存地址的比较

      */

        // function Person(name,age){
        //     //给对象加属性
        //     this.name = name;
        //     this.age = age;
        //     this.showname = function(){
        //         alert(this.name);
        //     }

        // }
        // var p1 = new Person('二狗',20);
        // //p1.showname();//二狗
        // var p2 = new Person('二狗',20);

        // console.log( p1 === p2 );//false,对象

        // var a = 20;
        // var b = 20;
        // console.log( a === b);//true

        // var arr = {age:20};
        // var a = arr;
        // a = null;
        // a.age = 8888;
        // console.log( arr.age );//8888

        /* constructor

         构造函数实例的constructor属性指向构造函数(类型)



         */


        function Person(name,age){
            //给对象加属性
            this.name = name;
            this.age = age;
            this.showname = function(){
                alert(this.name);
            }

        }
        var p1 = new Person('二狗',20);
        //console.log( p1.constructor );//Person构造

        function fn(){}
        var fn1 = new fn();
        //console.log( fn1.constructor )//fn构造函数

        //对象就是由函数构造出来的

        //console.log( fn.constructor ) //Function























    </script>
</html>
